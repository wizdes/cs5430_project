ASSURANCE.txt, which describes how and what you tested in the software being submitted. Also describe here any other means you used to increase assurance in the correctness of the system and in the absence of vulnerabilities.

Table of Contents
1) Overview 
2) Unit Test Cases
3) Other Assurance Mechanics
	a) Sealed Object
	b) SecureRandom
	c) RSA Encryption/Decryption
		i) size of Keys
	d) AES Encryption/Decryption
		i) size of Keys
	e) Nonces
	f) HMACs

1) Overview 

We used a combination of standard Java implementations of security measures as well as unit tests on every package of our system to increase assurance in the correctness of our system.

2) Unit Test Cases

We introduced unit tests for each package of our cryptographic substrate. 

3) Other Assurance Mechanics

There are several other assurance measures that were taken to increase the assurance in the correctness of the system.

a) SealedObject
We used the Java class 'SealedObject' to encapsulates a Java object and encrypts it.
b) SecureRandom
We used the Java class 'SecureRandom' to general random numbers securely.
c) RSA Encryption/Decryption
	We are using the standard Java class KeyPairGenerator with the 'RSA' algorithm. This is initialized with the highest level of SecureRandom (from the Javadocs). It encrypts/decrypts with the 'RSA/ECB/PKCS1Padding' algorithm.
	i) size of Keys
	We are using a 2048 bit RSA keys.
d) AES Encryption/Decryption
e) Nonces
	We are using nonces to ensure the system is not susceptible to replay attacks. The specific protocols in using nonces during machine authentication is detailed in FUNCTIONALITY.txt.
f) HMACs
	We are using HMACs to ensure the integrity of the data we are sending. The HMAC is generated using the standard Java implementation of HMACs.